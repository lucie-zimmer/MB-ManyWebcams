---
title: "ManyWebcams: web-based eye-tracking"
author: "CDS preliminary analysis"
date: '`r format(Sys.time(), "%a %b %d %X %Y")`'
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: yes
editor_options: 
  chunk_output_type: inline
---

When loading the packages for this script, you can choose to use [groundhog](https://groundhogr.com/) by setting `use_groundhog = T`. Groundhog will install packages from `2022-10-09` and ensures that the functions keep working the same way as when the script was last developed. If you prefer to load packages the conventional way, leave `use_groundhog = F` (default).

```{r libraries, results='hide', message=FALSE, warning=FALSE}
# should R use groundhog
use_groundhog <- F

# set vector w/ packages
packages = c("readr",
             "knitr",
             "tidyr",
             "dplyr",
             "ggplot2",
             "psych",
             "effsize",
             "Matrix",
             "lme4",
             "lmerTest",
             "carData",
             "effects",
             "stringr",
             "here")

# load packages
if(use_groundhog == T){
  packages_date <- "2022-10-09" 
  install.packages("groundhog")
  library(groundhog) # v2.0.1
  groundhog::groundhog.library(pkg = packages, date = packages_date)
  rm(packages, packages_date, use_groundhog) # clean
}else{
  # if necessary install
  installed_packages <- packages %in% rownames(installed.packages())
  if(any(installed_packages == F)){install.packages(packages[!installed_packages])}
  # load packages
  invisible(lapply(packages, library, character.only = T))
  # clean
  rm(installed_packages, packages, use_groundhog)
}

knitr::opts_chunk$set(cache = TRUE, warn = FALSE, message = FALSE)
options(scipen=999)
```

# Intro
Analysis script for the ManyWebcams web-based eye-tracking study.

# Setting constants
```{r}
FILE_NAME_PILOT <- "pilot_data.csv"

FILE_NAME_WEBCAM <- "relative_data.csv"
FILE_NAME_DEMO <- "demographic_data.csv"
FILE_NAME_EXCLUSION_AFTERPRE <- "participants_excluded_after_pre.txt"

# already excluded from the datasets, read for reporting
FILE_NAME_EXCLUSION_MANUAL <- "excluded_trials.csv"
FILE_NAME_EXCLUSION_SAMPLING <- "excluded_trials_samplingrate.txt"
  
DIR_NAME_DATA_MERGE <- "lab_data"
DIR_NAME_DATA_MERGE_OUTPUT <- "merge_output"
```

# File reading and processing
```{r}

data_pilot <- read.csv(FILE_NAME_PILOT, stringsAsFactors = TRUE)

# check if data merge is necessary
if(dir.exists(DIR_NAME_DATA_MERGE)){
  data_webcam_list <- list()
  data_demo_list <- list()
  
  posterior_exclusions <- c()
  samplingrate_exclusions <- c()
  manual_exclusions_list <- list()
  
  labs <- list.files(path=DIR_NAME_DATA_MERGE)
  for(lab in labs){
    
    data_webcam_part <- read.csv(file.path(DIR_NAME_DATA_MERGE, lab, FILE_NAME_WEBCAM), stringsAsFactors = TRUE)
    data_webcam_part$data_source <- lab
    data_webcam_list <- append(data_webcam_list, list(data_webcam_part))
    
    data_demo_part <- read.csv2(file.path(DIR_NAME_DATA_MERGE, lab, FILE_NAME_DEMO))
    data_demo_part$data_source <- lab
    data_demo_list <- append(data_demo_list, list(data_demo_part))
      
    manual_exclusions_part <- read.csv2(file.path(DIR_NAME_DATA_MERGE, lab, FILE_NAME_EXCLUSION_MANUAL))
    manual_exclusions_part$data_source <- lab
    manual_exclusions_list <- append(manual_exclusions_list, list(manual_exclusions_part))
    
    if (file.exists(file.path(DIR_NAME_DATA_MERGE, lab, FILE_NAME_EXCLUSION_AFTERPRE))){
      posterior_exclusions <- c(posterior_exclusions, readLines(file.path(DIR_NAME_DATA_MERGE, lab, FILE_NAME_EXCLUSION_AFTERPRE)))
    }
    
    f_exclusion_sampling <- file.path(DIR_NAME_DATA_MERGE, lab, FILE_NAME_EXCLUSION_SAMPLING)
    if (file.exists(f_exclusion_sampling)){
      
      samplingrate_exclusions_string <- readChar(f_exclusion_sampling, file.info(f_exclusion_sampling)$size)
      
      if(samplingrate_exclusions_string != "[]"){
        samplingrate_exclusions_string <- substr(samplingrate_exclusions_string, 3, nchar(samplingrate_exclusions_string)-2)
        
        if(grepl("', '", samplingrate_exclusions_string, fixed=T)){
          samplingrate_exclusions <- append(samplingrate_exclusions, unlist(strsplit(samplingrate_exclusions_string, "', '", fixed=T)))
        }else{
          samplingrate_exclusions <- append(samplingrate_exclusions, samplingrate_exclusions_string)
        }
      }
    }
  }
  
  rm(data_webcam_part, data_demo_part, manual_exclusions_part, samplingrate_exclusions_string)
  
  data_webcam <- do.call("rbind", data_webcam_list)
  data_webcam <- data_webcam[ , !(names(data_webcam) %in% c("X"))]
  data_demo <- do.call("rbind", data_demo_list)
  data_demo <- as.data.frame(unclass(data_demo), stringsAsFactors = TRUE)
  manual_exclusions <- do.call("rbind", manual_exclusions_list)

  
  if(!dir.exists(DIR_NAME_DATA_MERGE_OUTPUT)){
    dir.create(DIR_NAME_DATA_MERGE_OUTPUT)
  }
  
  write.csv(data_webcam, file.path(DIR_NAME_DATA_MERGE_OUTPUT, FILE_NAME_WEBCAM), row.names = FALSE)
  write.csv(data_demo, file.path(DIR_NAME_DATA_MERGE_OUTPUT, FILE_NAME_DEMO), row.names = FALSE)
  write.csv(manual_exclusions, file.path(DIR_NAME_DATA_MERGE_OUTPUT, FILE_NAME_EXCLUSION_MANUAL), row.names = FALSE)
  
  writeLines(posterior_exclusions,
              file.path(DIR_NAME_DATA_MERGE_OUTPUT, FILE_NAME_EXCLUSION_AFTERPRE))
  
  samplingrate_exclusions <- samplingrate_exclusions[samplingrate_exclusions != ""]
  print(samplingrate_exclusions) ##################
  samplingrate_exclusions_out <- paste(samplingrate_exclusions, collapse="', '")
  writeLines(paste("['", samplingrate_exclusions_out, "']", sep=""),
              file.path(DIR_NAME_DATA_MERGE_OUTPUT, FILE_NAME_EXCLUSION_SAMPLING))
  
}else{ # singular data source
  data_webcam <- read.csv(FILE_NAME_WEBCAM, stringsAsFactors = TRUE)
  data_webcam <- data_webcam[ , !(names(data_webcam) %in% c("X"))]
  
  data_demo <- read.csv2(FILE_NAME_DEMO, stringsAsFactors = TRUE)
  
  manual_exclusions <- read.csv2(FILE_NAME_EXCLUSION_MANUAL, stringsAsFactors = TRUE)
    
  posterior_exclusions <- c()
  if (file.exists(FILE_NAME_EXCLUSION_AFTERPRE)){
    posterior_exclusions <- readLines(FILE_NAME_EXCLUSION_AFTERPRE)
  }
  
  samplingrate_exclusions <- c()
  if (file.exists(FILE_NAME_EXCLUSION_SAMPLING)){
    
    samplingrate_exclusions_string <- readChar(FILE_NAME_EXCLUSION_SAMPLING, file.info(FILE_NAME_EXCLUSION_SAMPLING)$size)
    
    if(samplingrate_exclusions_string != "[]"){
      samplingrate_exclusions_string <- substr(samplingrate_exclusions_string, 3, nchar(samplingrate_exclusions_string)-2)
    
      if(grepl("', '", samplingrate_exclusions_string, fixed=T)){
        samplingrate_exclusions <- unlist(strsplit(samplingrate_exclusions_string, "', '", fixed=T))
      }else{
        samplingrate_exclusions <- c(samplingrate_exclusions_string)
      }
    } 

    rm(samplingrate_exclusions_string)
  }
}

View(data_webcam)
```

# Preprocessing

```{r}
# ManyWebcams data
## exclude toddler from the final data set after relative data was already calculated
data_webcam <- filter(data_webcam, !subid %in% posterior_exclusions)


## long to wide format
data_webcam$condition <- NULL
data_webcam$row <- NULL
data_webcam <- data_webcam %>% spread(aoi, freq)

## calculate relative looking score for target vs. distractor only
data_webcam$percorr <- round(data_webcam$target/(data_webcam$target+data_webcam$distractor), digits = 2)
data_webcam$distractor <- NULL
data_webcam$target <- NULL
data_webcam$none <- NULL

# MB2-Pilot data
data_inlab <- data_pilot %>%
  filter(experiment_num=="pilot_1a" & t >= -4000 & t <= 0) %>%
  group_by(subid) %>%
  summarize(
    lookingscore = sum(grepl("target", aoi, fixed = TRUE), na.rm = TRUE) / sum(grepl("target", aoi, fixed = TRUE) | grepl( "distractor", aoi, fixed = TRUE))
  )

## prepare inlab data for merging
colnames(data_inlab)[colnames(data_inlab) == 'lookingscore'] <- 'percorr'
data_inlab$percorr <- round(data_inlab$percorr, digits = 2)

# add method (webbased = 0, in-lab = 1)
data_webcam$method <- "webcam"
data_inlab$method <- "inlab"

# merge webbased & inlab
data <- rbind(data_webcam, data_inlab)
```

# Descriptives for ManyWebcams
For the children sample, a total of 50 participants were tested. From these, 15 had to be excluded due to technical errors with the eye tracking procedure (e.g., webcam could not be accessed, data upload) and 3 due to low sampling rate. From the remaining 32 participants, 2 had to be excluded due to interference (e.g., caregiver interfered with procedure or child was inattentive) during the procedure. These trials were identified by visual inspection. The final sample of included children is N = 30.
```{r}
# add info about gender and age to data
data_webcamDemo <- merge(data_webcam, data_demo, by = c("subid"))

data_webcamDemo$age <- data_webcamDemo$age_days
data_webcamDemo$gender <- data_webcamDemo$participant_gender
data_webcamDemo$country <- data_webcamDemo$residence_country

data_webcamDemo <- subset(data_webcamDemo, select = c(subid, age,  gender, country, percorr))

# calculate descriptives
## age in months
data_webcamDemo$age <- (data_webcamDemo$age/30.5)

## Get number of girls and boys
sum(data_webcamDemo$gender == "girl") #17
sum(data_webcamDemo$gender == "boy") #13

## Get residence country
summary(data_webcamDemo$country) # Germany: 19, UK: 8, Austria: 3

## Get age range
mean(data_webcamDemo$age) #22.27 months
sd(data_webcamDemo$age) #2.400 months
summary(data_webcamDemo$age) # min.:18.69 months, max.: 26.92 months

## Descriptives for ManyBabies2-Pilot
## n=65 (37 girls; mean age = 23.14 months; range 18.25 ro 26.84 months)
```

# Inferential Statistics
H1: Children will engage in goal-based action predictions, indicated by above-chance looking towards the loaction that matches the outcome of an agentÂ´s action goal
```{r, warning=FALSE}
t.test(data_webcam$percorr, mu = 0.5, alternative = "two.sided")
cohen.d(data_webcam$percorr ~ 1, mu = 0.5)
```

H2: Does the eye-tracking method have an effect on the measured proportional looking score? No strong directional hypothesis. (Method will be contrast coded (web-based = 0, lab-based = 1))
```{r, warning=FALSE}
# Error: number of levels of each grouping factor must be < number of observations (problems: subid)
# definition of new ID

#data$ID <- NA
#data$ID <- c(1:95)
#h2 <- lmer(percorr ~ method + (1|ID), data=data) #same error --> reason: only one observation per participant (no random slope)

data <- data%>%
  mutate(method = factor(method, levels = c("webcam", "inlab")))

h2 <- lm(percorr ~ method, data)

anova(h2)
summary(h2)
plot(allEffects(h2))

str(data$subid)
```

H3: Lower proportion of children who contribute usable data will be lower in webcam-based as compared to lab-based eye-tracking.

ManyWebcams: 60% included; exclusion due to technical problems (n= 15), low sampling rate (n= 3), manual exclusion: interference (n = 2)
ManyBabies2 Pilot: 89.04% included; exclusion due to early termination (n = 6), technical problems (n= 2)

```{r}
exclusion.table <- matrix(c(30, 65, 20, 8), nrow = 2, ncol = 2, byrow = T)
rownames(exclusion.table) <- c('included', 'excluded')
colnames(exclusion.table) <- c('online', 'in-lab')

exclusion.table

h3 <- chisq.test(exclusion.table)
h3 
# p-value sign., both variables are not independent
h3$expected
```


# preparation for plot
```{r}
# create values for error bars
mean(data_webcam$percorr) # 0.5898
mean(data_inlab$percorr)  # 0.7345

dataErrorbar <- group_by(data, method) %>%
  summarise(mean = mean(percorr), se = sd(percorr)/sqrt(n()), upper = mean + se, lower = mean - se)
```

# plot
```{r, warning=FALSE}
# plot the data
H2.plot <- ggplot(data, aes(x = method, y = percorr, colour = method, fill = method)) +
  geom_violin(alpha = 0.5, width = 1, position = position_dodge(width = 0.9), show.legend = FALSE ) +
  geom_jitter(aes(colour = method),  size = 2, alpha = 0.6, position = position_jitterdodge(jitter.width = 0.2, jitter.height = 0, dodge.width = 0.9), show.legend = FALSE) +
 geom_point(aes(x = method, y = mean), dataErrorbar, inherit.aes = FALSE, size = 2, color = "black") +
  geom_errorbar(aes(x = method, ymax = upper, ymin = lower), dataErrorbar, inherit.aes = FALSE, 
             stat = "identity", width = 0.05, color = "black") +
  ylim(0, 1) +
  scale_colour_manual(values=c("skyblue", "red"))  +
  scale_fill_manual(values=c("skyblue",  "red")) +
  geom_hline(yintercept=0.5, linetype="dashed", color = "black") +
  labs(title="Proportion Looking Score per method", x="Method", y="Proportion Looking Score (target/target+distractor)") +
  scale_x_discrete(labels=c("lab" = "in-lab", "online" = "online")) +
  theme_classic()

print(H2.plot)
```
# Bayesian analysis

Bayesian version of the model because it gives us more flexibility with respect to the response distribution (`lm` simply assumes normal distribution but ours is truncated given that we work with proportions).

```{r}
#visualize response distribution
# distribution is truncated by 0 and 1 and skewed - Beta distribution might be suited to model this

ggplot(data, aes(x = percorr))+
  geom_histogram(fill = NA, col = "black")+
  theme_bw()
```


```{r}
library(brms)
library(tidybayes)

# modifying the data because beta regression requires values larger than 0 and smaller than 1
mdata <- data%>%
  mutate(percorr = ifelse(percorr == 0, 0.000001, percorr),
         percorr = ifelse(percorr == 1, 0.999999, percorr))

bm1 <- brm(percorr ~ method,
           data = mdata,
           family = Beta(),
           iter = 2000, warmup = 1000, cores = 4, chains = 4
           )

# check how well the model is able to reproduce the data
pp_check(bm1)

# model summary
bm1
```


```{r}
# create a new dataset with posterior predictions for the mean for each setting
post <-mdata%>%
  distinct(method)%>%
  add_epred_draws(bm1)

# plot the predicted model average (with 95% CrI) and the data
ggplot(post, aes(x = .epred, y = method, fill = method))+
  geom_vline(xintercept = 0.5, lty = 3, alpha = .5)+
  geom_point(data = mdata, aes(x = percorr, y = method, col = method),pch = 1,alpha = .5)+
  stat_halfeye(alpha = .75, .width = c(0.66, 0.95))+
  scale_colour_manual(values=c("skyblue", "red"))  +
  scale_fill_manual(values=c("skyblue",  "red")) +
  labs(x = "Proportion Looking Score (target/target+distractor)", y = "Method")+
  theme_bw()
```


